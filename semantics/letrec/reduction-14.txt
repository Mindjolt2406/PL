[] |-
  let rec fact = (fun n -> if ((n) = (1)) then (1) else ((fact) (n - 1) * n)) in ((fact) (3))
=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |- (fun n -> ...) (3)
=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |- if ((3) = (1)) then (1) else ((fact) (3 - 1) * 3))

=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |- ((fact) (3 - 1) * 3))

=========================================================================
/*
  Here, look up for 'fact' into the environment finds a recursive closure against
  fact. The closure returned is enhanced by adding back fact.
*/
[
fact : {{ (fun n -> if ...), [] }}
]
  |- (((fun n -> ...) 2) * 3))

=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |- (if ((2) = (1)) then (1) else (((fact) (2 - 1)) * 2) ) * 3
=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |- (((fact) (2 - 1)) * 2) ) * 3

=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |- (((fun n -> ... ) (1)) * 2) ) * 3
=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |-  
      (
        (
          if (1) = (1) then
            (1)
          else 
          (
            ((fact) (1 - 1)) * 1
          )
        )  * 2
      ) * 3
       
=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |-  (
        (
          (1)
        ) * 2
      ) * 3
=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |-  (
        2
      ) * 3
=========================================================================
[
fact : {{ (fun n -> if ...), [] }}
]
  |- 6 
